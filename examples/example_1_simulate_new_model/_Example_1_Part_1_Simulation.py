import matplotlib.pyplot as plt
import os
from   numba             import jit
from   pathlib           import Path

import setup_bmss                as lab
import BMSS.models.model_handler as mh
import BMSS.models.setup_sim     as sm
import BMSS.simulation           as sim

'''
Example 1 Part 1: Simulating a New Model
- Learn the minimum steps required for simulation
'''

plt.style.use(lab.styles['dark_style'])
plt.close('all')

if __name__ == '__main__':
    
    '''
    The steps for analyzing a model not in the database are as follows:
        1. Read the settngs file with BMSS.models.setup_sim.from_config
        2. Read the core model file with BMSS.models.model_handler.from_config
        3. Get the arguments required for analysis with BMSS.models.get_models_and_params
    
    Use this method when:
        1. You are not sure if you want to save the model yet
        2. You expect to reformulate the model as you go along
    
    Note: 
        1. A .py file containing a function for numerical integration will be
          generated by get_models_and_params. Do not delete or rename the file 
          while your code is running.
        2. Details on core_model are in Tutorial 1 Part 1
        3. Details on storing core_model in the database are in Tutorial 1 Part 2
        4. Details the data structures models and params
    '''
    #Read model
    #Details in Tutorial 1 Part 1
    core_model       = mh.from_config('testmodel.ini')
    user_core_models = {core_model['system_type']: core_model}
    
    #Read settings
    #Details in Tutorial 2 Part 1
    filename    = 'settings_sim_1.ini'
    config_data = sm.from_config(filename)
    
    #Get arguments for simulation
    models, params, config_data = sm.get_models_and_params(filename, user_core_models=user_core_models)
    
    '''
    The steps for analyzing a model in the database are as follows:
        1. Call the function BMSS.models.setup_sim.get_models_and_params
    
    Use this method when:
        1. You want to resuse models while writing less code
        2. You want to avoid accidentally touching/modifying the model
        3. You want to avoid 
    
    Code:
    filename    = 'settings_sim_1.ini'
    
    new_models, new_params, new_config_data = sm.get_models_and_params(filename)
    '''
    
    #Integrate the models numerically
    #Details in Tutorial 2 Part 2
    ym, _ = sim.integrate_models(models, params)
    
    '''
    The results of the integration are stored in ym as a nested dictionary in the
    form of ym[model_num][scenario_num][row] where row is a row index in params.
    Meanwhile, ym[model_num][0] contains the time array for the model.
    Thus, suppose we only have one model. ym will then have one key.
    If that model has 2 scenarios, ym[1] will have 2 keys not including 0.
    Finally, if there are two rows of parameters, ym[1][1] and ym[1][2] will have two keys each.
    '''
    print('Keys in ym:', ym.keys())
    print('Keys in ym[1]', ym[1].keys())
    print('Keys in ym[1][1]', ym[1][1].keys())
    
    ##Plot Settings
    '''
    The following arguments follow a similar format to models where the first key corresponds to the model being integrated.
    The definition of the values indexed by those keys are as follows:
    plot_index : A list of state variables to plot as well as extra functions for plotting.
    titles     : A list of title names corresponding the states in plot_index. This argument is optional.
    labels     : A dict of scenario: name pairs that will be used in the legend. This argument is optional.                            
    '''
    plot_index  = {1: ['m', 'p'],
                   }
    titles      = {1: {'m': 'Model 1 mRNA', 'p': 'Model 1 Protein'},
                   }
    labels      = {1: {1: 'Scenario 1', 2: 'Scenario 2'}
                   }
    
    figs, AX = sim.plot_model(plot_index, ym, titles=titles, labels=labels)
    
    #Plotting extra variables
    '''
    Sometimes, we might want to examine quantities that are not time series of the state variables.
    In this case, we can come up with our own functions to evaluate extra variables.
    This extra function takes of the form of func(y, t, params).
    The arrays in ym and their corresponding rows in params are fed into this function.
    The return values are:
        1. The y axis values
        2. The x axis values
        3. The marker used for plotting (Refer to matplotlib)
    '''
    
    @jit(nopython=True)
    def synthesis_p(y, t, params):
        '''
        filler
        x: Time
        y: synthesis_rate
        filler
        '''
        m = y[:,0]
        
        synp = params[3]
        
        synthesis_rate = synp*m
        
        return synthesis_rate, t, '-'
        
    ym, em = sim.integrate_models(models, params, synthesis_p)
    
    '''
    em is a nested dictinary in the form em[function][model_num][scenario_num][row]
    '''
    
    #Modify the plot settings accordingly
    plot_index  = {1: ['p', synthesis_p],
                   }
    titles      = {1: {'p': 'Model 1 Protein', synthesis_p: 'Rate of Protein Synthesis'},
                   }
    labels      = {1: {1: 'Scenario 1', 2: 'Scenario 2'}
                   }
    
    figs, AX = sim.plot_model(plot_index, ym, e=em, titles=titles, labels=labels) 

    '''
    We can export the data for our external analysis in csv format.
    '''
    #Prefix at the front of the filenames
    prefix = ''
    
    #A new folder will be created using this directory. The files will be stored here.
    directory = Path(os.getcwd()) / 'simulation_results'
    
    sim.export_simulation_results(ym, em, prefix=prefix, directory=directory)
