import matplotlib.pyplot as plt
from   numba             import jit

import setup_bmss            as lab
import BMSS.models.setup_sim as sm
import BMSS.models.setup_sen as ss
import BMSS.simulation       as sim
import BMSS.sensitivityanalysis as sn

'''
Tutorial 3 Part 2: Sensitivity Analysis
- 
'''

plt.style.use(lab.styles['dark_style'])
plt.close('all')

if __name__ == '__main__':
    '''
    In this example, we want to engineer a pathway for the production of a 
    heterologous protein through a batch reaction. The protein product has a
    negative (toxic) effect on the growth of the cells. 
    
    mu = mu_max*s/(s+Ks)*Kh/(h+Kh)
	
	dx =  x*mu
	ds = -dx/Y
	dh = synh -h*mu
    
    Increasing the strength of the rbs would result in faster synthesis and boost 
    the product yield however, this effect might be reduced when the toxicity 
    of the protein is high enough to affect growth. 
    
    We want to consider how the yield at 7 hours is affected by changing the
    rbs strength (synh) and extent of growth inhibition(Kh). In addition, we have two strains
    of bacteria that we want to study; a fast-growing one and a slow-growing one (this
    affects mu_max).
    '''
    
    filename = 'settings_sen_1.ini'
    
    '''
    The final concentration of naringenin can be found using the objective function below. 
    Unlike the functions used for plotting extra variables, this one returns a single float.
    Note the difference!
    '''
    
    def h_yield(y, t, params):
        final_x = y[-1, 0]
        final_h = y[-1, 2]

        return final_x*final_h
    
    '''
    Our analysis makes use of the sensitivity analysis algorithms from SALib. The 
    first step is to prepare the arguments by reading a .ini file with the settings.
    '''
    
    sensitivity_args = ss.get_sensitivity_args(filename)
    
    print('Keys in sensitivity_args', sensitivity_args.keys())
    print()
    
    '''
    The difference in maximum growth rates for the fast (Strain 1) and slow-growing (Strain 2)
    strains are given by the different values of mu_max_1 in params. Let's relabel params
    to reflect this.
    '''
    sensitivity_args['params'].index = ['Strain 1', 'Strain 2']
    
    #For speed, reduce the number of samples.
    sensitivity_args['N'] = 500
    
    '''
    Next, we prepare the samples and problems as defined in the SALib documentation.
    '''
    
    samples, problems = sn.make_samples(models=sensitivity_args['models'], 
                                        params=sensitivity_args['params'], 
                                        fixed_parameters=sensitivity_args['fixed_parameters'], 
                                        parameter_bounds=sensitivity_args['parameter_bounds'], 
                                        analysis_type=sensitivity_args['analysis_type'], 
                                        N=sensitivity_args['N'])
    
    print('Sample parameters for model 1 generated from row "Strain 1" in parameters:')
    print(samples[1]['Strain 1'].round(3))
    print()
    
    '''
    We now call integrate_samples to evaluate the objective function. The results
    are returned as a nested dictionary in the form em[func][scenario][row]. This is 
    the same as that of em in Tutorial 2 Part 2.
    '''
    
    em = sn.integrate_samples(sensitivity_args['models'], samples, {1: [h_yield]})
    
    '''
    The objective function is evaluated for each sample and thus generates a 1-D array 
    indexed under em[func][scenario][row]. 
    '''
    
    print('Objective function values for model 1 scenario 1 generated by permuting row 0 in params')
    print('First 50 values')
    print (["{0:0.2e}".format(i) for i in em[1][1]['Strain 1'][h_yield][:50]])
    print()
        
    analysis_result = sn.analyze_sensitivity(em, samples, problems, analysis_type=sensitivity_args['analysis_type'])
    print(analysis_result[1][1]['Strain 1'][h_yield])
    
    '''
    The three steps can also be done in a single function call as shown below.
    
    sensitivity_args = ss.get_sensitivity_args(filename)
    sensitivity_args['params'].index = ['Strain 1', 'Strain 2']
    sensitivity_args['N'] = 500
    
    sensitivity_args['objective'] = {1: [h_yield]}
    analysis_result, em, samples, problems = sn.analyze(**sensitivity_args)
    '''
    
    #Plot settings
    titles = {1: {1: {0: {h_yield: 'h Yield'
                         }
                      }
                  }
              }
    #Shorthand version. Comment it out later to see the difference.
    titles = {1: {h_yield: 'h Yield'}
              }
    sn.plot_first_order(analysis_result, problems=problems, titles=titles, analysis_type=sensitivity_args['analysis_type'], figs=None, AX=None)
    
    '''
    Sobol analysis includes second order sensitivities. 
    We can call another function to plot the second order sensitivity.
    '''
    sn.plot_second_order(analysis_result, problems=problems, titles=titles, analysis_type=sensitivity_args['analysis_type'], figs=None, AX=None)
    
    