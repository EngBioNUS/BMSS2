import matplotlib.pyplot as plt
from   numba             import jit

import setup_bmss            as lab
import BMSS.models.setup_sim as sm
import BMSS.models.setup_sen as ss
import BMSS.simulation       as sim
import BMSS.sensitivityanalysis as sn

'''
Tutorial 3 Part 1: Sensitivity Analysis
- 
'''

plt.style.use(lab.styles['dark_style'])
plt.close('all')

if __name__ == '__main__':
    #Recap on making simulation settings templates
    # system_types_settings_names = [('BMSS, TestModel, Naringenin, RBSStrength, PromoterStrength', None),
    #                                ]
    # sm.make_settings_template(system_types_settings_names, filename='settings_sim_template.ini')
    
    
    
    # models, params, config_data = sm.get_models_and_params('sim_settings_1.ini')
    
    # config_data = ss.from_config(filename)
    '''
    In this example, we want to engineer a pathway for the synthesis of naringenin.
    In particular, we are interested in how sensitive the concentration of Naringenin
    is a result of tuning the promoters and RBSs of our genetic circuits. You'll find
    the system of equations in our settings file. 
    '''
    
    filename = 'settings_sim_1.ini'
    
    '''
    The final concentration of naringenin can be found using the objective function below. 
    Unlike the functions used for plotting extra variables, this one returns a single float.
    Note the difference!
    '''
    
    def Nar_yield(y, t, params):
        return y[-1, -1]
    
    '''
    Our analysis makes use of the sensitivity analysis algorithms from SALib. The 
    first step is to prepare the arguments by reading a .ini file with the settings.
    '''
    
    sensitivity_args = ss.get_sensitivity_args(filename)
    
    print('Keys in sensitivity_args', sensitivity_args.keys())
    print()
    
    params = sensitivity_args['params']
    models = sensitivity_args['models']
    fixed_parameters = sensitivity_args['fixed_parameters']
    parameter_bounds = sensitivity_args['parameter_bounds']
    
    
    sensitivity_args['N'] = 30
    import pandas as pd
    
    
    '''
    Next, we prepare the samples and problems as defined in the SALib documentation.
    '''
    
    samples, problems = sn.make_samples(models=sensitivity_args['models'], 
                                        params=sensitivity_args['params'], 
                                        fixed_parameters=sensitivity_args['fixed_parameters'], 
                                        parameter_bounds=sensitivity_args['parameter_bounds'], 
                                        analysis_type=sensitivity_args['analysis_type'], 
                                        N=sensitivity_args['N'])
    
    print('Sample parameters for model 1 generated from row 0 in parameters:')
    print(samples[1][0].round(3))
    print()
    
    '''
    We now call integrate_samples to evaluate the objective function. The results
    are returned as a nested dictionary in the form em[func][scenario][row]. This is 
    the same as that of em in Tutorial 2 Part 2.
    '''
    
    em = sn.integrate_samples(models, samples, Nar_yield)
    
    '''
    The objective function is evaluated for each sample and thus generates a 1-D array 
    indexed under em[func][scenario][row]. 
    '''
    
    print('Objective function values for model 1 scenario 1 generated by permuting row 0 in params')
    print (["{0:0.2e}".format(i) for i in em[Nar_yield][1][1][0]])
    print()
        
    sn.analyze_sensitivity(em, samples, problems, analysis_type=sensitivity_args['analysis_type'])
    
    '''
    Notice how the format is the same as that for simulation. 
    You can in fact reuse this file for simulation.
    '''